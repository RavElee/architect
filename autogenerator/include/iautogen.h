#ifndef IAUTOGEN_H
#define IAUTOGEN_H

#include <algorithm>
#include <cassert>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>


class autogenerator
{
protected:
    std::fstream fs;
    std::stringstream ss;
    std::map<size_t, std::string> method_desctiptor {{0, "result_type"}, {1, "name"}, {2, "args"}};

public:
    virtual ~autogenerator() = default;
    void generate(std::filesystem::path &&in_dir, std::filesystem::path &&out_dir)
    {
        for (const auto &dir_iter : std::filesystem::directory_iterator {in_dir})
        {
            ss << file2str(dir_iter);

            std::vector<std::string> includes_iface;
            std::vector<std::string> includes_adapter;
            std::vector<std::string> namespaces;
            std::vector<std::string> classes;
            std::map<size_t, std::vector<std::string>> methods;

            size_t method_id = 0;
            for (std::string line; std::getline(ss, line);)
            {
                if (line.compare("[[included_iface]]") == 0)
                    fillParam(includes_iface, line);
                if (line.compare("[[included_adapter]]") == 0)
                    fillParam(includes_adapter, line);
                if (line.compare("[[namespace]]") == 0)
                    fillParam(namespaces, line);
                if (line.compare("[[class]]") == 0)
                    fillParam(classes, line);

                // method идут друг за другом
                if (line.compare("[[method]]") == 0)
                {
                    std::getline(ss, line);
                    while (line.find("[[end]]") == std::string::npos)
                    {
                        methods[method_id].push_back(line);
                        std::getline(ss, line);
                        if (line.compare("[[method]]") == 0)
                        {
                            std::getline(ss, line);
                            method_id++;
                        }
                    }
                }
            }

            // for (const auto &it : methods)
            // {
            //     auto iter = it.second.begin();
            //     auto idx = iter->find(" const");
            //     if(idx != std::string::npos)
            //     {
            //         // std::cout << "name: " << iter->substr(0, idx) << "()" << iter->substr(idx) << std::endl;
            //         iter++;
            //     }
            //     else
            //     {
            //         iter++;
            //         // std::cout << "name: " << *iter << std::endl;
            //     }

            //     // while (iter != it.second.end())
            //     // {
            //     //     std::cout << "args: " << *iter++ << std::endl;
            //     // }
            // }

            ss.str("");
            ss.clear();


            auto generateInterface = [&includes_iface, this, &classes, &methods, &namespaces, &out_dir]
            {
                ss << "\n/*\n\tThis is autogenerated code!\n\tDo not edit this!\n*/\n";
                auto className = classes.front();
                std::transform(className.begin(), className.end(), className.begin(), ::toupper);
                ss << "#ifndef " << className << "_INTERFACE_H\n";
                ss << "#define " << className << "_INTERFACE_H\n\n";;
                for(const auto& it : includes_iface)
                    ss << "#include<" << it << ">\n";
                ss << "\n";

                for(const auto& it : namespaces)
                    ss << "namespace " << it << " {\n";

                std::string interface_name;
                for(const auto& it : classes)
                {
                    interface_name = it;
                    ss << "class " << it << "\n";
                    ss << "{\n";
                    ss << "public:\n";
                    ss << "\t"<<it <<"() = default;\n";
                    ss << "\tvirtual ~" << it <<"() = default;\n";
                }

                for(const auto& it : methods)
                {
                    size_t i = 0;
                    auto iter = it.second.begin();
                    ss << "\tvirtual " << *iter++ << " ";
                    auto idx = iter->find(" const");
                    bool isConst = (idx != std::string::npos) ? true : false;
                    ss << iter->substr(0, idx);
                    iter++;

                    ss <<"(";
                    size_t counter = 0;
                    while (iter != it.second.end()) {
                        ss << *iter++ << " var" << i++ << ",";
                        counter++;
                    }
                    // remove comma
                    if(counter != 0)
                        ss.seekp(-1, std::ios_base::end);
                    ss <<")";
                    if(isConst)
                        ss << " const ";
                    ss << "= 0;\n";
                }


                ss << "};\n"; // close class
                ss << "}\n"; // close namespace
                ss << "#endif\n";
                auto ifaceDir = out_dir / "interfaces/";
                write(ifaceDir, interface_name);
            };

            auto generateAdapter = [&includes_adapter, this, &classes, &methods, &namespaces, &out_dir]
            {
                ss << "\n/*\n\tThis is autogenerated code!\n\tDo not edit this!\n*/\n";
                auto className = classes.front();
                std::transform(className.begin(), className.end(), className.begin(), ::toupper);
                ss << "#ifndef " << className << "_ADAPTER_H\n";
                ss << "#define " << className << "_ADAPTER_H\n\n";;

                for(const auto& it : includes_adapter)
                    ss << "#include<" << it << ">\n";
                ss << "\n";

                for(const auto& it : namespaces)
                    ss << "namespace " << it << " {\n";

                std::string interface_name;
                for(const auto& it : classes)
                {
                    interface_name = it;
                    ss << "class " << it + "_adapter" << ": public " << it << "\n";
                    ss << "{\n";
                    ss << "protected:\n";
                    ss << "\tshared_uobject obj;\n";
                    ss << "public:\n";
                    ss << "\texplicit "<< it << "_adapter(shared_uobject obj): obj(obj){};\n\n";
                }

                for(const auto& it : methods)
                {
                    size_t i = 0;
                    auto iter = it.second.begin();
                    auto result_type = *iter++;

                    auto idx = iter->find(" const");
                    bool isConst = (idx != std::string::npos) ? true : false;
                    auto name = iter->substr(0, idx);
                    iter++;
                    ss << "\t" << result_type << " " << name;
                    ss <<"(";
                    size_t counter = 0;
                    while (iter != it.second.end()) {
                        ss << *iter++ << " var" << i++ << ",";
                        counter++;
                    }
                    // remove comma
                    if(counter != 0)
                        ss.seekp(-1, std::ios_base::end);
                    ss <<") ";
                    if(isConst)
                        ss << "const ";
                    ss << "override\n";
                    ss << "\t{\n";
                    if(result_type != "void")
                    {
                        ss << "\t\treturn *ioc::resolve<" << result_type << ", shared_uobject>(\""<< interface_name << "."<<name <<"\", obj);\n";
                    }
                    else
                    {
                        auto idx = (i == 0) ? i : i - 1;
                        ss << "\t\tioc::resolve<" << "engine::command" << ">(\""<< interface_name << "."<<name <<"\", obj, "<< "var" << idx <<")->execute();\n";
                    }
                    ss << "\t}\n\n";
                }
                ss << "};\n"; // close class
                ss << "}\n"; // close namespace
                ss << "#endif\n";

                auto adaptersDir = out_dir / "adapters/";
                write(adaptersDir, interface_name + "_adapter");
            };

            generateInterface();
            ss.str("");
            ss.clear();
            generateAdapter();
            ss.str("");
            ss.clear();

            // _generate(out, ifaceName);

            ss.str("");
            ss.clear();
            fs.clear();
        }
    }

protected:
    void write(std::filesystem::path &out, std::string name)
    {
        if (fs.is_open())
            return;
        fs.open(out / (name + std::string(".h")), std::ios_base::out);
        fs.write(ss.str().c_str(), ss.str().size());
        fs.close();
    }

    std::string file2str(const std::filesystem::directory_entry& dir_iter)
    {
        fs.open(dir_iter.path(), std::ios_base::in);
        if (!fs.is_open())
            throw std::runtime_error("couldn't open file");

        auto size = dir_iter.file_size();
        if (size == 0)
        {
            fs.close();
            throw std::runtime_error("zero size file");
        }

        char *buf = new char[size];
        std::memset(buf, 0, size);
        fs.read(buf, size - 1);

        std::string storage(buf);
        delete[] buf;
        if (fs.is_open())
            fs.close();
        return storage;
    }

    void fillParam(std::vector<std::string>& param, std::string& line)
    {
        std::getline(ss, line);
        while (line.find("[[") == std::string::npos)
        {
            param.push_back(line);
            std::getline(ss, line);
        }
    }
};

#endif // IAUTOGEN_H
